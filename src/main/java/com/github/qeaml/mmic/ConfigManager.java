package com.github.qeaml.mmic;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.function.Function;

public class ConfigManager<Cfg> {
  private Cfg config;
  private File src;
  private Properties props;
  private List<Field> validFields;
  private Map<String, Object> defaults;
  private static Map<Class<?>, Function<String, ?>> deserializers;
  private static Map<Class<?>, Function<Object, String>> serializers;

  static {
    deserializers = new HashMap<>();
    deserializers.put(String.class,  s -> s);
    deserializers.put(Integer.class, s -> Integer.parseInt(s));
    deserializers.put(Double.class,  s -> Double.parseDouble(s));
    deserializers.put(Boolean.class, s -> Boolean.parseBoolean(s));
    deserializers.put(Config.LagType.class, s -> Config.LagType.valueOf(s));

    serializers = new HashMap<>();
    serializers.put(String.class,  s -> s.toString());
    serializers.put(Integer.class, i -> i.toString());
    serializers.put(Double.class,  d -> d.toString());
    serializers.put(Boolean.class, b -> b.toString());
    serializers.put(Config.LagType.class, l -> l.toString());
  }

  public ConfigManager(Cfg instance, File source) {
    config = instance;
    src = source;
    defaults = new HashMap<>(16);
    validFields = Arrays.stream(config.getClass().getDeclaredFields())
      // collect all public static fields
      .filter(this::isValidField)
      // get the default values
      .filter(f -> {
        try {
          defaults.put(f.getName(), f.get(null));
        } catch(IllegalAccessException iae) {
          return false;
        }
        return true;
      })
      // ensure we can change the values
      .filter(f -> {
        try {
          f.set(null, defaults.get(f.getName()));
        } catch(IllegalAccessException iae) {
          return false;
        }
        return true;
      })
      .toList();
    props = new Properties(validFields.size());
  }

  public void load() {
    try(var fr = new FileReader(src)) {
      props.load(fr);
    } catch(IOException ioe) {
      Client.log.error("Could not load Config: "+ ioe.getLocalizedMessage());
    }

    for(Field f: validFields) {
      if(!props.containsKey(f.getName())) {
        Client.log.error("Missing config entry: "+f.getName());
        continue;
      }
      if(!deserializers.containsKey(f.getType())) {
        Client.log.error("Cannot deserialize type: "+f.getType().getName());
        continue;
      }
      var de = deserializers.get(f.getType());
      try {
        f.set(null, de.apply((String)props.get(f.getName())));
      } catch(IllegalAccessException iae) {
        // exception ignored since (100% theoretically) it should never happen
        // see line 31
      }
    }
  }

  public void save() {
    for(Field f: validFields) {
      if(!serializers.containsKey(f.getType())) {
        Client.log.error("Cannot serialize type: "+f.getType().getName());
        continue;
      }
      var se = serializers.get(f.getType());
      try {
        props.put(f.getName(), se.apply(f.get(null)));
      } catch(IllegalAccessException iae) {
        // again, shouldn't happen: line 23
      } 
    }

    try(var fw = new FileWriter(src)) {
      props.store(fw, "  File generated by MMIC; please do not edit manually!");
    } catch(IOException ioe) {
      Client.log.error("Could not save Config: "+ ioe.getLocalizedMessage());
    }
  }

  private static final int reqModifier = Modifier.STATIC|Modifier.PUBLIC;
  private boolean isValidField(Field f) {
    return (f.getModifiers() & reqModifier) == reqModifier;
  }
}
